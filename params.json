{"name":"Building Test Fixtures with Random Data","tagline":"","body":"One of the challenges testing a system with a large domain and a complex data model is setting up fixtures to test against.  Once we move beyond unit tests and want to create real objects with real data – either as part of the setup stage of an automated test or for manually testing – then things become more challenging:\r\n* The data items we care about for the test may not all live on the object; our test might be interested in the payroll cut-off date for an employee for instance, but concerning ourselves with the details of where that data goes and the object graph needed to correctly set it all up is error prone and time consuming\r\n* Extra code in our tests concerned with fixture details just adds noise to the test: it makes it harder to understand and adds to the maintenance burden.\r\n* False-negatives: To get valid fixtures  we might well have to set up other bits of data and other objects that our test just doesn’t care about, otherwise our tests fail for reasons unrelated to our test scenario\r\n* False-positives: Tests might unwittingly pass because we’ve left fields empty that we don’t (think we) care about for the purposes of our test e.g. our test only works properly because something is null or false etc.\r\n\r\nAs an example let’s imagine a simple employee that we want to create for our test:\r\n\r\n`public class Employee {\r\n\tString firstname;\r\n\tString surname;\r\n\tLocalDate dateOfBirth;\r\n\tBigDecimal basicSalary;\r\n\tAddress homeAddress;\r\n…\r\n}`\r\n\r\n\r\nAnd some typical test code to create one:\r\n\r\n`public class EmployeeTest {\r\n\tprivate final LocalDate DATE_OF_BIRTH = new LocalDate().minusYears(50);\r\n\tEmployee employee;\r\n\r\n\t@Before\r\n\tPublic void setUpEmployee(){\r\n\t\temployee = new Employee();\r\n\t\temployee.setDateOfBirth(DATE_OF_BIRTH);\r\n}\r\n\r\n}`\r\n\r\n\r\nFor our test purposes we’re only interested in the age of our employee, but you can see we’re already getting bogged down with concerns about the rest of the data on our employee – what if the database requires non-null values for firstname and surname, what if the address is required too?  Just what’s involved with making an Address object? And will it matter if the salary’s not set to anything? I’m not interested in salary here but maybe I should make something up in case having a null salary makes something weird happen elsewhere.  You can imagine how quickly this complexity escalates with real code.\r\n\r\n## Enter the Builder\r\nUsing the Builder Pattern to create our fixtures can address some of these issues, the main idea is that all the fields in our object are pre-populated, we only need to override the contents of the fields that we care about before telling the builder to build() our object:\r\n\r\n`public class EmployeeBuilder {\r\n\tprivate LocalDate dateOfBirth = new LocalDate().minusYears(30);\r\n\tprivate String firstname = “Firstname”;\r\n\tprivate String surname = “Surname”;\r\n\tprivate BigDecimal basicSalary = new BigDecimal(20000);\r\n\tprivate Address homeAddress = AddressBuilder.addressBuilder().build();\r\n\r\n\tprivate EmployeeBuilder(){}\r\n\r\n\tpublic static EmployeeBuilder employeeBuilder(){\r\n\t\treturn new EmployeeBuilder();\r\n\t}\r\n\r\n\tpublic EmployeeBuilder firstname(String firstname) {\r\n\t\tthis.firstname = firstname;\r\n\t\treturn this;\r\n\t}\r\n\r\npublic EmployeeBuilder surname(String surname) {\r\n\t\tthis.surname = surname;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic EmployeeBuilder age(int age) {\r\n\t\tthis.dateOfBirth = new LocalDate().minusYears(age);\r\nreturn this;\r\n}\r\n\r\n\tpublic EmployeeBuilder dateOfBirth(int age) {\r\n\t\tthis.dateOfBirth = new LocalDate().minusYears(age);\r\n\t\treturn this;\r\n}\r\n\r\npublic EmployeeBuilder basicSalary(BigDecimal salary){\r\n\tthis.basicSalary = basicSalary;\r\n\treturn this;\r\n}\r\n\r\npublic EmployeeBuilder basicSalary(Integer salary) {\r\n\tthis.basicSalary = new BigDecimal(salary);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic EmployeeBuilder homeAddress(Address address) {\r\n\t\tthis.homeAddress = homeAddress;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tPublic Employee build(){\r\n\t\tEmployee employee = new Employee();\r\n\t\temployee.setFirstname(firstname);\r\n\t\temployee.setSurname(surname);\r\n\t\temployee.setDateOfBirth(dateOfBirth);\r\n\t\temployee.setBasicSalary(basicSalary);\r\n\t\temployee.setHomeAddress(homeAddress);\r\n\t\treturn employee;\r\n}`\r\n\r\n\r\nThis makes our test setup look a bit nicer and takes away some of the concerns we were having:\r\n\r\n`public class EmployeeTest {\r\n\tprivate final Integer AGE = 50;\r\n\tEmployee employee;\r\n\r\n\t@Before\r\n\tPublic void setUpEmployee(){\r\n\t\temployee = EmployeeBuilder.employeeBuilder().age(AGE).build();\r\n}\r\n\r\n}`\r\n\r\n\r\nA nice feature of builders is that you can add and overload methods to make fixture setup simpler: in our EmployeeBuilder we’ve overloaded basicSalary() so you can supply a simple Integer and it will convert it to the required BigDecimal for you, also the dateOfBirth(LocalDate) method is accompanied by an age(Integer) method so you can make your test code simpler and more readable by avoiding the boilerplate of massaging a LocalDate.  Finally you may have noticed that the homeAddress field is populated initially with … an AddressBuilder!\r\n\r\n## Better Data\r\nWe’ve made our test setup a lot better with the builder but we can do better with the quality of the default data.  At the moment every test that uses our builder is going to get an Employee with exactly the same default attributes which may create its own false-positive problem for us.  What we need is random data:\r\n\r\n`public class EmployeeBuilder {\r\n\r\n\tprivate Date dateOfBirth = Random.pastDate(years(17), years(64)).next();\r\n\tprivate String firstname = Random.string(50).next();\r\n    \tprivate String surname = Random.string(50).next();\t\r\nprivate BigDecimal basicSalary = Random.bigDecimal(1000000).next();\tprivate Address homeAddress = AddressBuilder.addressBuilder().build();\r\n…`\r\n\r\n\r\nWell this looks exciting!  Let’s take a look at the Random class:\r\n\r\n`public class Random {\r\n\r\n    \tpublic static Generator<String> string = new StringGenerator(10);\r\n    \tpublic static Generator<Integer> integer = new IntegerGenerator(Integer.MAX_VALUE);\r\npublic static Generator<BigDecimal> bigDecimal = new BigDecimalGenerator(999999, 2);\r\n…`\r\n\r\nIt’s basically a collection of static Generator<T> members and some static helper methods.  Let’s look at the Generator<T> and the IntegerGenerator classes:\r\n\r\n`public abstract class Generator<T> implements Iterator<T> {\r\n    @Override\r\n    public boolean hasNext() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void remove() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\r\n\r\nclass IntegerGenerator extends Generator<Integer> {\r\n\r\n    private static java.util.Random random = new java.util.Random();\r\n    private Integer max;\r\n\r\n    public IntegerGenerator(Integer max) {\r\n        this.max = max;\r\n    }\r\n\r\n    @Override\r\n    public Integer next() {\r\n        return random.nextInt(max);\r\n    }\r\n}`\r\n\r\n\r\nGenerator<T> is a never-ending abstract Iterator<T> implementation leaving it up to the extending classes to implement next(). IntegerGenerator simply returns a new random integer between 0 and the specified maximum for each call to next().  You can see the default version provided by Random.integer uses Integer.MAX_VALUE when it creates it and it also provides a utility method to create your own IntegerGenerator with a different maximum if needed:\r\n\r\n`public static Generator<Integer> integer(Integer max) {\r\n        return new IntegerGenerator(max);\r\n    }`\r\n\r\n\r\nAnd that is the general idea with all the other types we want to generate.  The default Random.string implementation creates a StringGenerator that returns a 10-character long random string, Random.string(Integer) will give you a StringGenerator that generates a random string of the given length if you need it, there are generators for dates, selecting enums at random and so on.  \r\nGenerating data with tighter formatting needs makes life a lot easier too, here’s an email address generator:\r\n\r\n`public class EmailAddressGenerator extends Generator<String> {\r\n    @Override\r\n    public String next() {\r\n        return format(\"%s@%s.%s\", Random.string(10).next(), Random.string(10).next(), Random.values(\"com\", \"co.uk\", \"gov.uk\" , \"org\", \"net\").next());\r\n    }\r\n}`\r\n\r\n\r\nA postcode generator:\r\n\r\n`public class PostcodeGenerator extends Generator<String> {\r\n    @Override\r\n    public String next() {\r\n        return format(\"%s%s%01d %01d%s\",\r\n                random(1, \"ABCDEFGHIJKLMNOPRSTUWYZ\"),\r\n                random(1, \"ABCDEFGHKLMNOPQRSTUVWXY\"),\r\n                Random.integer(9).next(),\r\n                Random.integer(9).next(),\r\n                random(2, \"ABDEFGHJLNPQRSTUWXYZ\"));\r\n    }\r\n}`\r\n\r\n\r\nAnd a random URI generator:\r\n\r\n`public class UriGenerator extends Generator<URI> {\r\n    @Override\r\n    public URI next() {\r\n        try {\r\n            return new URI(String.format(\"http://%s.%s\", Random.string.next(), Random.values(\"com\", \"co.uk\", \"org\").next()));\r\n        } catch (URISyntaxException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}`\r\n\r\n\r\nCheck out the rest of the code in the repository (Link here to the Orbit github or bitbucket repository), in future posts we’ll look at how to reproduce the random data used in test failures in the build and how to manage more complicated fixture setups.\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}